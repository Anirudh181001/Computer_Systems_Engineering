# Computer_Systems_Engineering
1004557 Anirudh Shrinivason

FI followed the instructions given in the google documents thoroughly for the TODOs 1,2,3,4 b). I was also able to pass all the neessary test cases by following the instructions given carefully. The only alteration in design is for the part a) of TODO 4, ie: the implementation for the revival of worker processes.

I first checked the buffer in order to assign proesses to the workers. I found whether there are any free workers available to carry forward a new process by initializing a variable called slot_is_found. This variable is initially set to 0 and is switched to 1 when a worker is found to carry a process forward. A new job is assigned under the condition that 'shmPTR_jobs_buffer[i].task_status == 0' and that it is alive. If it is dead, then we must revive it first, before assigning a job to it.The process revival by itself was implemented using fork(), similar to the function create_children(). Then, a new job is assigned to that specific process.

I used a fairly simple, however,appropriate and efective approach to terminate legally the workers that are still alive. I started with traversing through each process and checked whether their status is 0; ie: if they are free and have not taken up by any job. If they are, then we assign 'shmPTR_jobs_buffer[i].task_type = 'z' to make sure that the specific worker process is legally terminated. A counter (death_count) was used, initialized to 0 at start and incremements after killing each process. Finally,it returns true and breaks the loop if the counter equals the number of all processes, ensuring that it has traversed through all processes alive.
